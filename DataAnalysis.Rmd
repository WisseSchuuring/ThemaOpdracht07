---
title: "DataAnalysis"
author: "Wisse Schuuring"
date: "2/15/2022"
output: pdf_document
---

```{r setup, message=FALSE}

library(ggplot2)
library(dplyr)
library(xtable)
library(PoiClaClu)
library(affy)
library(scales)
library(pheatmap)
library(DESeq2)
library(pander)

```

# Exploratory Data Analysis


```{r}
#reading in the parental sample files.
sample_1_p <- read.csv(file = "Data/SamplesTSV/GSM3733674_sample1.tsv",
                       sep = "\t", header=T, skip = 3)
sample_4_p <- read.csv(file = "Data/SamplesTSV/GSM3733677_sample4.tsv",
                       sep = "\t", header=T, skip = 3)
sample_5_p <- read.csv(file = "Data/SamplesTSV/GSM3733678_sample5.tsv",
                       sep = "\t", header=T, skip = 3)

#reading in the IRF2 knockout files.
sample_2_KO <- read.csv(file = "Data/SamplesTSV/GSM3733675_sample2.tsv",
                        sep = "\t", header=T, skip = 3)
sample_3_KO <- read.csv(file = "Data/SamplesTSV/GSM3733676_sample3.tsv",
                        sep = "\t", header=T, skip = 3)
sample_6_KO <- read.csv(file = "Data/SamplesTSV/GSM3733679_sample6.tsv",
                        sep = "\t", header=T, skip = 3)


#removing the "values" column in both parental and knockout files.
s1p <- sample_1_p[c("ID_REF", "count")]
s4p <- sample_4_p[c("ID_REF", "count")]
s5p <- sample_5_p[c("ID_REF", "count")]

s2k <- sample_2_KO[c("ID_REF", "count")]
s3k <- sample_3_KO[c("ID_REF", "count")]
s6k <- sample_6_KO[c("ID_REF", "count")]
```

Read in the files and removed the unnecessary value value, for the only ones of interest are the id and the counts value.


```{r}
# Merge the parental data
first_merge_parental <- merge(s1p, s4p, by="ID_REF")
final_merge_parental <- merge(first_merge_parental, s5p, by="ID_REF")
names(final_merge_parental)[2] <- c("counts_1_p")
names(final_merge_parental)[3] <- c("counts_4_p")
names(final_merge_parental)[4] <- c("counts_5_p")
final_merge_parental$counts_avg_p <- rowMeans(final_merge_parental[2:4])


# Merge the IRF2KO data
first_merge_IRF2KO <- merge(s2k, s3k, by="ID_REF")
final_merge_IRF2KO <- merge(first_merge_IRF2KO, s6k, by="ID_REF")
names(final_merge_IRF2KO)[2] <- c("counts_2_KO")
names(final_merge_IRF2KO)[3] <- c("counts_3_KO")
names(final_merge_IRF2KO)[4] <- c("counts_6_KO")
final_merge_IRF2KO$counts_avg_KO <- rowMeans(final_merge_IRF2KO[2:4])


# Merge both datasets into a completed dataset
MyData <- merge(final_merge_parental, final_merge_IRF2KO, by="ID_REF")

# Write the merged dataset to a seperate file " MyData.csv".
write.csv(MyData,file = 'Data/Samples/Reformat/MyData.csv', row.names=F)

```

With the data finally cleaned up, a simple read.table() shall reveal its contents.

## Reading in the Data

```{r}
# Reading the first five rows of MyData.csv file into R as a table.
read.table(file="Data/Samples/Reformat/MyData.csv", sep=",",
           header=T, row.names=1, nrows = 5)
```

## Data Dimensions

The data set contains the identifier for the gene, followed by the amount of times this gene has been expressed within it's respective sample. In addition, there are "total" columns with the sum of these counts for the IRF2 Knockout samples, and the parental samples. These can be used for comparison's sake. All of these values are integers, therefore easy to work with.

```{r}
# Reading the data set as MyData
MyData <- read.csv(file = "Data/Samples/Reformat/MyData.csv", header = T)

#Show the amount of rows and columns in MyData
Dimensions <- dim(MyData)
cat("The data set contains", Dimensions[1],
    "rows and",Dimensions[2],"columns.\n")

#Show the structure of the data set.
pander(str(MyData))
cat("All values within the data set are integers,
    as expected from a numeric value such as a count.\n")
```

## Creating R Objects

```{r}
# create R objects to store classification
counts_p <- 2:4
counts_KO <- 6:8
counts_avg <- c(5,9)
compare_1_2 <- c(2,6)
compare_4_3 <- c(3,7)
compare_5_6 <- c(4,8)
ref_out <- MyData[c(2:4,6:8)]

```

Six R objects are created. The counts objects to keep track of individual counts, as well as a comparison between both totals. The compare objects compare one specific parental expression count value with one specific IRF2 Knockout expression count value. 

## Summarising and Boxplot

```{r}
# Summarise the Data
pander(summary(MyData))

# Create a boxplot displaying the logged data of the six samples.
boxplot(log2(ref_out + 1),
        data=MyData, main="Gene expression between Parental and IRF2 KO",
        xlab="Gene Samples",
        ylab="Log of Gene expressions",
        col = c("orange","orange",
                "orange","dark Blue",
                "dark Blue","dark Blue"),
        las=2, par(cex.axis=0.46),
        names=c("Parent 1","Parent 2",
                "Parent 3","Knockout 1",
                "Knockout 2", "Knockout 3"))
```

A summary shows that most data points do indeed equal zero. The following boxplot reveals however that the data samples overall are very balanced, as they should be, and can all be used for the research. 

## Density Plot

```{r}
## Create a vector of 2 colors to use.
myColors <- c("Orange","dark Blue")

## Plot the log2-transformed data with a 0.1 pseudocount
plotDensity(log2(ref_out + 0.1), col=rep(myColors, each=3),
            lty=c(1:ncol(ref_out)), xlab='Log2(count)',
            main='Expression Distribution')

## Add a legend and vertical line
legend('topright', names(ref_out), lty=c(1:ncol(ref_out)),
       col=rep(myColors, each=3))
abline(v=-1.5, lwd=1, col='red', lty=2)
```
Considering there are barely to no shifts between the peaks of the different samples, it can be concluded that the data is of high quality.

## Normalisation

```{r}
## Created a boxplot using MDS
barplot(colSums(ref_out) / 1e6, las = 2,
        col=rep(myColors, each=3),
        main = "Sequencing Depth",
        xlab = "Gene Samples",
        ylab = "Sequencing Depth (in millions)",
        names=c("Parent 1","Parent 2","Parent 3",
                "Knockout 1","Knockout 2", "Knockout 3"),
        cex.names=0.45)
```

```{r}

# DESeq2 will construct a SummarizedExperiment object and combine this 
# into a 'DESeqDataSet' object. The 'design' argument usually indicates the 
# experimental design using the condition(s) names as a 'factor',
# for now we use just '~ 1'
(ddsMat <- DESeqDataSetFromMatrix(countData = ref_out,
                                  colData = data.frame(samples = names(ref_out)),
                                  design = ~ 1))
```
```{r}
# Perform normalization
rld.dds <- vst(ddsMat)
# 'Extract' normalized values
rld <- assay(rld.dds)
```

## Distance Calculation

```{r}
# Calculate basic distance metric (using euclidean distance, see '?dist')
sampledists <- dist( t( rld ))
```

## Heatmap

```{r}

# Convert the 'dist' object into a matrix for creating a heatmap
(sampleDistMatrix <- as.matrix(sampledists))

# The annotation is an extra layer that will be plotted above the heatmap columns
# indicating the cell type
annotation <- data.frame(Cell = factor(rep(1:2, each = 3),
                                          labels = c("Parental", "IRF2 KO")))

# Set the rownames of the annotation dataframe to the sample names (required)
rownames(annotation) <- names(ref_out)

pheatmap(sampleDistMatrix, show_colnames = FALSE,
         annotation_col = annotation,
         clustering_distance_rows = sampledists,
         clustering_distance_cols = sampledists,
         main = "IRF2 Knockout Sample Distances")
```
## Multi Dimensional Scaling (MDS)

```{r}
# Use the raw (not r-log transformed!) counts
dds <- assay(ddsMat)
poisd <- PoissonDistance( t(dds) )
# Extract the matrix with distances
samplePoisDistMatrix <- as.matrix(poisd$dd)
# Calculate the MDS and get the X- and Y-coordinates
mdsPoisData <- data.frame( cmdscale(samplePoisDistMatrix) )

# And set some better readable names for the columns
names(mdsPoisData) <- c('x_coord', 'y_coord')

# Separate the annotation factor (as the variable name is used as label)
groups <- factor(rep(1:2, each=3), 
                 labels = c("Parental", "IRF2 KO"))
coldata <- names(ref_out)

# Create the plot using ggplot
ggplot(mdsPoisData, aes(x_coord, y_coord, color = groups, label = coldata)) + 
  geom_text(size = 4) +
  ggtitle('Multi Dimensional Scaling') +
  labs(x = "Poisson Distance", y = "Poisson Distance") +
  theme_bw()
```
There is a clear poisson distance between the parental and the IRF2 KO gene samples. As this data set only contains 3 samples of each group, as well as the fact the data itself does not contain any missing values, it can be fully utilized for research. 

# Discovering Differentialy Expressed Genes

FILTER OUT LOW COUNT DATA



```{r}

MyData <- read.table(file="Data/Samples/Reformat/MyData.csv", sep=",",
           header=T, row.names=1)

MyData <- MyData[,c(1:3,5:7)]
# Perform a naive FPM normalization
# Note: log transformation includes a pseudocount of 1

counts.fpm <- log2( (MyData / (colSums(MyData) / 1e6)) + 1 )

#if ever value of a row have values of zero, remove them
row_sub <- apply(counts.fpm, 1, function(row) all(row > 5 ))
row_removed <- apply(counts.fpm, 1, function(row) any(row <= 5))

# Show the identifiers of the genes that were removed due to containing 0 values
removed_genes <- counts.fpm[row_removed,]

# Show the remaining genes and their count values
genes <- counts.fpm[row_sub,]

totalAmount <- dplyr::count(MyData)[[1]]
keepAmount <- dplyr::count(genes)[[1]]
removeAmount <- dplyr::count(removed_genes)[[1]]

keepPercent <- round((keepAmount*100)/totalAmount)
removedPercent <- round((removeAmount*100)/totalAmount)

cat("The total amount of genes in the data is",totalAmount,
    ". Of those genes,",keepAmount,
    " were above a count of zero, with",removeAmount,
    " equal to it or below. In conclusion,",keepPercent,
    "% of the data will be kept, while",removedPercent,"% will be removed.")
  
```

CALCULATE THE FOLD CHANGE VALUE

# The Fold Change Value (FC)

"Differential expression analysis was performed using the voom/limma R package
(38). Genes were considered to be differentially expressed if the log2
of the fold change was >1 or < 1 and the adjusted P value was <0.05"

```{r}
# gene_avg <- MyData[c(4,8)]
# avg.fpm <- log2( (gene_avg / (colSums(MyData) / 1e6)) + 1 )
# avg.fpm
# p1 <- hist(avg.fpm$counts_avg_p, col="Orange")
# p2 <- hist(avg.fpm$counts_avg_KO, col="Blue")
# plot( p1, col=rgb(1,0.5,0,1/1.8), main = "Fold Change Values Frequencies")
# plot( p2, col=rgb(0,0,1,1/1.8), add=T)
# legend(8, 2500, legend = c("Parental","Knockout"), fill = c("Orange","Blue"))

myTTest <- function(y){
  return(t.test(y[1:3], y[4:6])$p.value)
}
gene.names <- rownames(genes)
samples <- colnames(genes)

pVec <- apply(genes, 1, myTTest)
alpha <- 0.05
sum(pVec < alpha)

```



